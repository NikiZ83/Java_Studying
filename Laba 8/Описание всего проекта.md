## Файлы проекта (содержимое)

### DataProcessor.java
```java
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.annotation.ElementType;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface DataProcessor {
}
```

### Person.java
```java
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return name + "," + age;
    }
}
```

### DataManager.java
```java
import java.io.*;
import java.lang.reflect.Method;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors;

public class DataManager {
    private List<Person> data = new ArrayList<>();

    private static class ProcessorEntry {
        final Object instance;
        final Method method;

        ProcessorEntry(Object instance, Method method) {
            this.instance = instance;
            this.method = method;
        }
    }

    private final List<ProcessorEntry> processors = new ArrayList<>();
    private final ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());

    /**
     * Регистрирует объект-обработчик: все методы с аннотацией @DataProcessor
     * должны иметь сигнатуру: List<Person> name(List<Person> input)
     */
    public void registerDataProcessor(Object processor) {
        for (Method m : processor.getClass().getDeclaredMethods()) {
            if (m.isAnnotationPresent(DataProcessor.class)) {
                m.setAccessible(true);
                processors.add(new ProcessorEntry(processor, m));
                System.out.println("Registered processor: " + processor.getClass().getSimpleName() + "." + m.getName());
            }
        }
    }

    public void setData(List<Person> data) {
        this.data = new ArrayList<>(data);
    }

    public List<Person> getData() {
        return Collections.unmodifiableList(data);
    }

    /**
     * Загружает данные из CSV-файла формата: name,age (без заголовка)
     */
    public void loadData(String sourcePath) throws IOException {
        List<Person> list = new ArrayList<>();
        try (BufferedReader br = new BufferedReader(new FileReader(sourcePath))) {
            String line;
            while ((line = br.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty()) continue;
                String[] parts = line.split(",");
                if (parts.length >= 2) {
                    String name = parts[0].trim();
                    int age = Integer.parseInt(parts[1].trim());
                    list.add(new Person(name, age));
                }
            }
        }
        this.data = list;
        System.out.println("Loaded " + list.size() + " records from " + sourcePath);
    }

    /**
     * Применяет зарегистрированные процессоры по очереди. Каждый процессор
     * получает текущий список и должен вернуть новый список. Внутри методов
     * рекомендуется использовать Stream API и parallelStream() для параллельной обработки.
     */
    public void processData() {
        for (ProcessorEntry entry : processors) {
            Callable<List<Person>> task = () -> {
                try {
                    Object result = entry.method.invoke(entry.instance, data);
                    if (result instanceof List) {
                        //noinspection unchecked
                        return (List<Person>) result;
                    } else {
                        System.err.println("Processor returned non-list: " + entry.method);
                        return data; // ничего не меняем
                    }
                } catch (Exception e) {
                    throw new RuntimeException("Error invoking processor " + entry.method, e);
                }
            };

            Future<List<Person>> future = executor.submit(task);
            try {
                List<Person> newData = future.get();
                if (newData != null) {
                    this.data = new ArrayList<>(newData);
                }
                System.out.println("Processor completed: " + entry.instance.getClass().getSimpleName() + "." + entry.method.getName() + " -> records=" + data.size());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * Сохраняет данные в CSV-файл в формате name,age
     */
    public void saveData(String destinationPath) throws IOException {
        try (BufferedWriter bw = new BufferedWriter(new FileWriter(destinationPath))) {
            for (Person p : data) {
                bw.write(p.toString());
                bw.newLine();
            }
        }
        System.out.println("Saved " + data.size() + " records to " + destinationPath);
    }

    public void shutdown() {
        executor.shutdown();
    }
}
```

### FilterProcessor.java
```java
import java.util.List;
import java.util.stream.Collectors;

public class FilterProcessor {

    // Оставляем только людей 18 лет и старше
    @DataProcessor
    public List<Person> filterAdults(List<Person> input) {
        return input.parallelStream()
                .filter(p -> p.getAge() >= 18)
                .collect(Collectors.toList());
    }
}
```

### TransformProcessor.java
```java
import java.util.List;
import java.util.stream.Collectors;

public class TransformProcessor {

    // Приводим имена к верхнему регистру (параллельно)
    @DataProcessor
    public List<Person> uppercaseNames(List<Person> input) {
        return input.parallelStream()
                .map(p -> new Person(p.getName().toUpperCase(), p.getAge()))
                .collect(Collectors.toList());
    }
}
```

### AggregateProcessor.java
```java
import java.util.List;

public class AggregateProcessor {

    // Вычисляем средний возраст и печатаем в консоль; возвращаем исходный список
    @DataProcessor
    public List<Person> aggregateStats(List<Person> input) {
        double avg = input.parallelStream()
                .mapToInt(Person::getAge)
                .average()
                .orElse(0.0);
        System.out.println("[Aggregate] average age = " + avg);
        return input; // агрегирующая операция не меняет набор записей
    }
}
```

### Main.java
```java
import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        DataManager dm = new DataManager();

        // Регистрируем обработчики
        dm.registerDataProcessor(new FilterProcessor());
        dm.registerDataProcessor(new TransformProcessor());
        dm.registerDataProcessor(new AggregateProcessor());

        // Попытка загрузить input.csv, иначе используем встроенные данные
        File in = new File("input.csv");
        if (in.exists()) {
            try {
                dm.loadData(in.getPath());
            } catch (IOException e) {
                System.err.println("Error loading input.csv: " + e.getMessage());
                dm.setData(sampleData());
            }
        } else {
            System.out.println("input.csv not found — using sample data");
            dm.setData(sampleData());
        }

        // Обработка
        dm.processData();

        // Сохранение результатов
        try {
            dm.saveData("output.csv");
        } catch (IOException e) {
            System.err.println("Error saving output.csv: " + e.getMessage());
        }

        dm.shutdown();
    }

    private static List<Person> sampleData() {
        return Arrays.asList(
                new Person("Alice", 23),
                new Person("Bob", 17),
                new Person("Charlie", 35),
                new Person("Diana", 29),
                new Person("Eve", 15)
        );
    }
}
```

---

## Как компилировать и запускать
1. Поместите все файлы в одну папку.
2. Убедитесь, что у вас установлен JDK 8 или выше.
3. В терминале в папке с файлами выполните:

```
javac *.java -d out
java -cp out Main
```

4. Если в той же папке есть `input.csv` с содержимым `name,age` (по строкам), то программа загрузит его; иначе будет использован встроенный пример. Результат будет записан в `output.csv`.

---

## Заметки и возможные улучшения
- Подход, использованный здесь: аннотация помечает методы-обработчики с сигнатурой `List<Person> method(List<Person>)`. DataManager вызывает каждый обработчик по очереди; внутри обработчиков применён `parallelStream()` для параллельной обработки.
- Можно расширить: поддержка методов, возвращающих Stream<Person>, или методов, выполняющих агрегацию и возвращающих статистику; регистрация классов по сканированию пакета; чтение/запись в БД или сетевые ресурсы; более сложная организация конвейера (fan-out / merge).
- Если нужно, могу адаптировать код под схемы: (а) каждый обработчик работает на части данных в отдельных задачах (шардирование), (б) обработчики-станцыи конвейера запускаются параллельно с передачей результатов через очереди, (в) использование CompletableFuture для асинхронного комбинирования результатов.
ы

